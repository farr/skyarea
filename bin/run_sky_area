#!/usr/bin/env python
from __future__ import print_function

import matplotlib as mpl
mpl.use('Agg')

from optparse import OptionParser
from distutils.dir_util import mkpath
from lalinference.io import fits
from lalinference.io import hdf5
from lalinference.bayestar import moc
import numpy as np
import healpy as hp
import os
import six.moves.cPickle as pickle
import sky_area.sky_area_clustering as sac

import matplotlib.pyplot as plt


def plot_assign(output, skypost):
    k = skypost.k

    plt.clf()
    for i in range(k):
        sel = skypost.assign == i
        plt.plot(skypost.pts[sel, 0], skypost.pts[sel, 1], ',')

    plt.xlabel(r'$\alpha$')
    plt.ylabel(r'$\sin \delta$')

    plt.savefig(output)


if __name__ == '__main__':
    parser = OptionParser()

    parser.add_option('--outdir', help='output directory', default='.')
    parser.add_option('--samples', help='posterior samples file')

    parser.add_option('--fitsoutname', help='filename for the FITS file',
                      default='skymap.fits.gz')

    parser.add_option('--pdf', action='store_true', default=False,
                      help='output plots in PDF format [default: PNG]')

    parser.add_option('--loadpost',
                      help='filename for pickled posterior state')

    parser.add_option('--maxpts', type='int',
                      help='maximum number of posterior points to use')

    parser.add_option('--trials', type='int', default=5,
                      help='number of trials at each clustering number '
                      '[default: %default]')

    parser.add_option('--disable-distance-map', dest='enable_distance_map',
                      action='store_false', default=True,
                      help='disable output of healpy map of '
                      'distance mean and s.d.')

    parser.add_option('--objid', help='event ID to store in FITS header')

    parser.add_option('--seed', type=int, default=None,
                      help='use specified random seed')

    (args, remaining) = parser.parse_args()

    if args.seed is not None:
        np.random.seed(args.seed)
    if args.samples is None:
        parser.error('missing required argument: --samples')

    try:
        data = hdf5.read_samples(args.samples)
    except IOError:
        # FIXME: remove this code path once we support only HDF5
        from astropy.table import Table
        data = Table.read(args.samples, format='ascii')

    # Shuffle the data and take a random subsample.
    # Note that if arg.maxpts > len(data), then this
    # just selects the entire array.
    np.random.shuffle(data)
    data = data[:args.maxpts]

    mkpath(args.outdir)

    if args.loadpost is None:
        try:
            dist = data['dist']
        except KeyError:
            try:
                dist = data['distance']
            except KeyError:
                dist = None
        if dist is None:
            if args.enable_distance_map:
                parser.error("The posterior samples file '{0}' does not have a distance column named 'dist' or 'distance'.  Cannot generate distance map.".format(args.samples))
            pts = np.column_stack((data['ra'], data['dec']))
        else:
            pts = np.column_stack((data['ra'], data['dec'], dist))
        skypost2d = sac.ClusteredSkyKDEPosterior(pts, ntrials=args.trials)
        if args.enable_distance_map:
            skypost3d = sac.Clustered3DKDEPosterior(pts, ntrials=args.trials)
            skyposts = (skypost2d, skypost3d)
        else:
            skyposts = (skypost2d,)

        print('pickling ...')
        with open(os.path.join(args.outdir, 'skypost.obj'), 'w') as out:
            pickle.dump(skyposts, out)
    else:
        with open(args.loadpost, 'r') as inp:
            skyposts = pickle.load(inp)
        skypost2d = skyposts[0]
        if args.enable_distance_map:
            if len(skyposts) < 2:
                parser.error("The pickle file '{0}' does not contain a 3D KDE.".foratm(args.loadpost))
            skypost3d = skyposts[1]

    print('plotting cluster assignments ...')
    if args.pdf:
        assign_out = os.path.join(args.outdir, 'assign2d.pdf')
    else:
        assign_out = os.path.join(args.outdir, 'assign2d.png')
    plot_assign(assign_out, skypost2d)
    if args.enable_distance_map:
        if args.pdf:
            assign_out = os.path.join(args.outdir, 'assign3d.pdf')
        else:
            assign_out = os.path.join(args.outdir, 'assign3d.png')
        plot_assign(assign_out, skypost3d)

    print('making skymap ...')
    hpmap = skypost2d.as_healpix()
    hpmap.meta['creator'] = parser.get_prog_name()
    if args.objid is not None:
        hpmap.meta['objid'] = args.objid
    if args.enable_distance_map:
        order, ipix = moc.uniq2nest(hpmap['UNIQ'])
        nside = 2 ** order.astype(int)
        theta, phi = hp.pix2ang(nside, ipix.astype(np.int64), nest=True)
        pts = np.column_stack((phi, 0.5 * np.pi - theta))
        _, hpmap['DISTMU'], hpmap['DISTSIGMA'], hpmap['DISTNORM'] = \
            skypost3d.posterior(pts, distances=True)
        hpmap.meta['distmean'] = np.mean(dist)
        hpmap.meta['diststd'] = np.std(dist)

    names = data.dtype.names
    if 'time' in names:
        hpmap.meta['gps_time'] = data['time'].mean()
    elif 'time_mean' in names:
        hpmap.meta['gps_time'] = data['time_mean'].mean()
    elif 'time_maxl' in names:
        hpmap.meta['gps_time'] = data['time_maxl'].mean()
    else:
        parser.error(
            "Cannot find time, time_mean, or time maxl variable in posterior.")

    fits.write_sky_map(os.path.join(args.outdir, args.fitsoutname),
                       hpmap, nest=True)
