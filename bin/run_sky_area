#!/usr/bin/env python
from __future__ import print_function

import matplotlib as mpl
mpl.use('Agg')

from optparse import OptionParser
from distutils.dir_util import mkpath
from lalinference.io import fits
from lalinference.io import hdf5
import numpy as np
import os
import sys
import six.moves.cPickle as pickle
import sky_area.sky_area_clustering as sac

import matplotlib.pyplot as plt


def plot_assign(output, skypost):
    k = skypost.k

    plt.clf()
    for i in range(k):
        sel = skypost.assign == i
        plt.plot(skypost.pts[sel, 0], skypost.pts[sel, 1], ',')

    plt.xlabel(r'$\alpha$')
    plt.ylabel(r'$\sin \delta$')

    plt.savefig(output)


if __name__ == '__main__':
    parser = OptionParser()

    parser.add_option('--outdir', help='output directory', default='.')
    parser.add_option('--samples', help='posterior samples file')

    parser.add_option('--fitsoutname', help='filename for the FITS file',
                      default='skymap.fits.gz')

    parser.add_option('--pdf', action='store_true', default=False,
                      help='output plots in PDF format [default: PNG]')

    parser.add_option('--loadpost',
                      help='filename for pickled posterior state')

    parser.add_option('--maxpts', type='int',
                      help='maximum number of posterior points to use')

    parser.add_option('--trials', type='int', default=5,
                      help='number of trials at each clustering number '
                      '[default: %default]')

    parser.add_option('--disable-distance-map', dest='enable_distance_map',
                      action='store_false', default=True,
                      help='disable output of healpy map of '
                      'distance mean and s.d.')

    parser.add_option('--objid', help='event ID to store in FITS header')

    parser.add_option('--seed', type=int, default=None,
                      help='use specified random seed')

    (args, remaining) = parser.parse_args()

    if args.seed is not None:
        np.random.seed(args.seed)
    if args.samples is None:
        parser.error('missing required argument: --samples')

    try:
        data = hdf5.read_samples(args.samples)
    except IOError:
        # FIXME: remove this code path once we support only HDF5
        from astropy.table import Table
        data = Table.read(args.samples, format='ascii')

    # Shuffle the data and take a random subsample.
    # Note that if arg.maxpts > len(data), then this
    # just selects the entire array.
    np.random.shuffle(data)
    data = data[:args.maxpts]

    mkpath(args.outdir)

    if args.loadpost is None:
        try:
            dist = data['dist']
        except KeyError:
            try:
                dist = data['distance']
            except KeyError:
                dist = None
        if dist is None:
            if args.enable_distance_map:
                parser.error("The posterior samples file '{0}' does not have a distance column named 'dist' or 'distance'.  Cannot generate distance map.".format(args.samples))
            pts = np.column_stack((data['ra'], data['dec']))
        else:
            pts = np.column_stack((data['ra'], data['dec'], dist))
        if args.enable_distance_map:
            KDEClass = sac.Clustered3DKDEPosterior
        else:
            KDEClass = sac.ClusteredSkyKDEPosterior
        skypost = KDEClass(pts, ntrials=args.trials)

        print('pickling ...')
        with open(os.path.join(args.outdir, 'skypost.obj'), 'w') as out:
            pickle.dump(skypost, out)
    else:
        with open(args.loadpost, 'r') as inp:
            skypost = pickle.load(inp)

    print('plotting cluster assignments ...')
    if args.pdf:
        assign_out = os.path.join(args.outdir, 'assign.pdf')
    else:
        assign_out = os.path.join(args.outdir, 'assign.png')
    plot_assign(assign_out, skypost)

    print('making skymap ...')
    hpmap = skypost.as_healpix()
    hpmap.meta['creator'] = parser.get_prog_name()
    if args.objid is not None:
        hpmap.meta['objid'] = args.objid
    if args.enable_distance_map:
        hpmap.meta['distmean'] = np.mean(dist)
        hpmap.meta['diststd'] = np.std(dist)

    names = data.dtype.names
    if 'time' in names:
        hpmap.meta['gps_time'] = data['time'].mean()
    elif 'time_mean' in names:
        hpmap.meta['gps_time'] = data['time_mean'].mean()
    elif 'time_maxl' in names:
        hpmap.meta['gps_time'] = data['time_maxl'].mean()
    else:
        parser.error(
            "Cannot find time, time_mean, or time maxl variable in posterior.")

    fits.write_sky_map(os.path.join(args.outdir, args.fitsoutname),
                       hpmap, nest=True)
